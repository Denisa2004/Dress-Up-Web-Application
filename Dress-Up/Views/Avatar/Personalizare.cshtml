@*
    aici o sa fie in stanga avatarul pe care l-am ales, care se actualizeaza constant cand selectez un item, 
    iar in dreapta o sa fie toate optiunile de personalizare (adica dressing ul)
        - o sa am un buton de salvare care sa salveze avatarul personalizat
        - o sa am un buton de resetare care sa reseteze avatarul la starea initiala

*@
@{
    ViewData["Title"] = "Personalizare Avatar";
    var avatarId = ViewBag.AvatarId;
}

<h2>Personalizează-ți avatarul</h2>

<div style="display: flex; justify-content: center; gap: 3rem;">
    <!-- canvas cu avatarul -->
    <div>
        <canvas id="avatarCanvas" width ="400" height ="650" style="border: 1px solid gray;"></canvas> <!--aici trebuie modificat ca sa ia dimensiunile automate-->
    </div>

    <!-- dressing-ul -->
    <!--pentru un item: <button onclick="updateLayer('categ', 'pathImagine')">Păr 1</button> -->
</div>

<div>
    <button onclick="saveAvatar()">Salvează outfit</button> @* butonul acesta va aparea doar daca user ul este logat *@
    <button onclick=" = "resetAvatart()">Resetează avatarul</button>
</div>

@section Scripts {
    <script>
        // initializare layers, adica doar base, fara haine
        let layers = {
            base: '@Url.Content($"~/images/base{avatarId}.png")',
            hair: null,
            top: null,
            pants: null,
            accesories: null
        };


        // desenare avatar
        function drawAvatar() {
            const canvas = document.getElementById("avatarCanvas");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);


            const Categories = ['base', 'pants', 'top', 'accesories', 'hair']; // ordinea e importanta la suprapunere
            Categories.forEach(categ => {
                if (layers[categ]) {
                    const img = new Image();
                    img.src = layers[categ];
                    img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // aici va trebui personalizata pentru fiecare categorie deoarece nu toate vor fi puse de la 0 0
                }
            });
        }

        function resetAvatar() {
            layers = {
                base: '@Url.Content($"~/images/base{avatarId}.png")',
                hair: null,
                top: null,
                pants: null,
                accesories: null
            };
            drawAvatar();
        }

        // actualizarea unui layer
        function updateLayer(categ, imagePath) {
            layers[categ] = imagePath;
            drawAvatar();
        }

        // salvare
        function saveAvatar() {
            const canvas = document.getElementById("avatarCanvas");
            const imageData = canvas.toDataURL("image/png");

            fetch('/Avatar/Save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(imageData) // se trimite un string in log de dto
            })
                .then(response => response.json())
                .then(data => {
                    console.log("Imagine salvată la:", data.imagePath);
                    alert("Avatar salvat cu succes!");
                })
                .catch(error => {
                    console.error("Eroare:", error);
                });
        }


        // desenare initiala la deschiderea paginii
        window.onload = () => {
            drawAvatar();
        };
    </script>
}
